## C언어 입출력 & 연산자 정리

### 스트림(Stream)이란?

- 프로그램과 입출력 장치(키보드, 모니터, 파일 등) 사이의 데이터 흐름을 의미
- 입력 스트림(Input Stream): 데이터가 프로그램으로 들어옴 (scanf, fscanf)
- 출력 스트림(Output Stream): 프로그램에서 데이터가 나감 (printf, fprintf)

### 버퍼 (Buffer)

- 스트림은 실제로 데이터를 즉시 보내지 않고, 버퍼(임시 저장소)에 모았다가 일정 조건에서 한 번에 전송
- 이유 : 장치와 CPU 속도 차이가 커서 효율을 맞추기 위함

### 버퍼 비우기

- 출력 버퍼 비우기 : fflush(stdout);

→출력 버퍼에 쌓인 데이터를 강제로 화면에 내보냄

- 입력 버퍼 비우기 : fflush(stdin); 은 표준 C에서 정의되지 않음(비권장).
    - 안전한 방법 :

```c
while (getchar()!='\n' && getchar()!=EOF);
```

---

## 기본 구조 & 이스케이프

```c
printf("문자열과 값들: %d %f %s\n", 10, 3.14, "hi");
```

- 형식 문자열 안에 %로 자리를 만들고, 뒤 인자로 값을 채운다.
- % 자체 출력 → %%
- 이스케이프: \”(큰따옴표) \\(백슬래시) \n(줄바꿈) \t(탭) \a(경고음)

ex)

```c
printf("그는 말했다: \"피곤하다\".\n"); // 큰따옴표 출력
printf("퍼센트: 100%%\n");   // % 출력
```

---

## 변환 지정자

| **지정자**   | **의미**               | **예시** |
| ---         |     ---               |      --- |
| **%d, %i**  | 10진 정수(int)         | printf(”%d”, -42); |
| **%u**      | 10진 부호없는 정수      |
(unsigned)    |                       |
| **%x / %X** | 16진 정수(소문자/대문자) | printf(”%#x”, 10); // 0xa |
| **%o**      | 8진 정수               |                           |
| **%f**      | 고정소수 실수           |       printf(”%f”, 3.14); |
| **%e / %E** | 지수 표기              | 3.14e+00 |
| **%g / %G** | 짧은 쪽 선택(f 또는 e)  | 불필요한 0 제거 |
| **%a / %A** | 16진 부동소수           |  |
| **%c**      | 문자                   |  |
| **%s**      | 문자열(널 종료)         |  |
| **%p**      | 포인터(주소)            | printf(”%p”, (void*)ptr); |
| **%n**      | 지금까지 출력한 문자 수를 int*에 기록 |                |

> 지수 표기에 대해 : 컴퓨터 내부는 부동소수(지수 포함)로 저장할 수 있다. printf에서 사람이 보기 좋게 e표기로 표현할 수 있다는 뜻이다.
> 

---

| 플래그 | 의미 | 정수 예시 (i=42) | 실수 예시 (f=3.14) |
| --- | --- | --- | --- |
| - | 왼쪽 정렬 | %-7d → “42  “ | %-8.2f → “3.14  “ |
| + | 양수도 부호 출력 | %+7d → “  +42” | %+7.2f → “  +3.14” |
| (공백) | 양수면 앞에 공백 | % 7d → “  42” |  |
| 0 | 빈 칸을 0으로 채움
(오른쪽 정렬) | %07d → “0000042” | %07.2f는 정밀도가 있으면 0패딩과 상호작용 주의 |
| # | 대체 형식 | %#x → 0x0a, %#o → 052 / %#f → 소수점 강제 |  |

---

## 폭(width) & 정밀도(precision)

- %7d → 최소 7칸, 오른쪽 정렬
- %-7d → 최소 7칸, 왼쪽 정렬
- %07d → 최소 7칸, 0으로 채움
- %7.2f → 최소 7칸, 소수점 이하 2자리
- %.5s → 문자열 최대 5글자만 출

```c
int i=42;
double d=3.14159;
char *s="hello";

printf("[%7d]\n", i);    // [     42]
printf("[%-7d]\n", i);   // [42     ]
printf("[%07d]\n", i);   // [0000042]
printf("[%7.2f]\n", d);  // [   3.14]
printf("[%.3s]\n", s);   // [hel]
```

> *로 받은 폭이 음수면 자동으로 왼쪽 정렬(-) 플래그가 적용.
> 

---

| 길이   | 의미(printf)             | 예시                             |
| ---   | ---                      |                             --- |
| hh    | signed/unsigned char     | printf(”%hhd”, (signed char)x); |
| h     | short                    | printf(”%hd”, (short)x);        |
| (없음) | int                      | pritnf(”%d”, x);                |
| l     | long, wchar_t(문자/문자열) | printf(”%ld”, (long)x); / %lc, %ls |
| ll    | long long                | printf(”%lld”, (long long)x);   |
| z     | size_t                   | printf(’%zu”, sizeof x);        |
| t     | ptrdiff_t                | printf(”td, diff);              |
| j     | intmax_t                 | printf(”jd”, (intmax_t)x);      |
| L     | long double              | printf(”%Lf”, (long double)f);  |

---

## 주소/포인터 출력 — %p (필수)

```c
int x = 10;
int *px = &x;
printf("%p\n", (void*)px);
```

- %p만 주소 출력용으로 표준 보장
- %ul, %u 같은 걸로 주소를 찍는 건 잘못됨(플랫폼마다 크기 다름, **UB 위험**).
- 항상 %p + (void*)로 캐스팅

## UB(Undefined Behavior)란?

- C 표준에서 결과를 보장하지 않는 코드 실행을 뜻 함.
- 즉, “무슨 일이 일어날지 아무도 모른다”는 뜻이다.
- 컴파일러도 책임 안 지고, 운영체제도 책임 안 지는 상태.

### 왜 UB가 생길까?

C 언어는 저수준 언어라서, 성능과 이식성을 위해 일부 상황을 아예 “표준에서 정의하지 않음”

→ 그러면 컴파일러는 마음대로 최적화할 수 있음.

### UB의 예시

1. **잘못된 printf 서식**

```c
long x = 1234567890;
printf("%d\n", x);    // UB: %d는 int 전용인데 long을 줬음
```

- 어떤 시스템에서는 값이 잘려서 나오고
- 어떤 시스템에서는 쓰레기 값이 나오고
- 어떤 시스템에서는 아예 크래시 날 수도 있음.

1. **배열 범위 벗어나기**

```c
int arr[3] = {1,2,3};
printf("%d\n", arr[5]);     // UB: 배열 밖 접근
```

- 에러 날 수도 있고
- 이상한 값이 출력될 수도 있고
- 프로그램이 쩡히 돌아가는 척할 수도 있다.

1. **0으로 나누기**

```c
int a = 10/0; // UB
```

- 일부 컴퓨터 : 런타임 에러(”divide by zero”)
- 일부 : 그냥 쓰레기 값
- 일부 : 프로그램 종료

1. **잘못된 포인터 사용**

```c
int *p;
*p = 10;   // UB : 초기화 안 된 포인터 사용
```

### UB가 왜 위험한가?

- 예측 불가능 : 같은 코드도 PC, OS, 컴파일러마다 결과가 달라짐
- 최적화 때문에 더 위험 : 최신 컴파일러는 UB를 가정하고 코드를 “잘못된 방향”으로 최적화할 수도 있음
- 보안 문제 : 해커들이 UB를 이용해 프로그램을 깨뜨리는 경우 많음 (버퍼 오버플로우, 포인터 오염 등)

### 반대말 : Defined / Implementation-Defined

- Defined Behavior : 표준에서 “이렇게 동작한다” 보장된 경우 → 항상 같은 결과
- Implementation-Defined Behavior : 표준은 “컴파일러/플랫폼이 선탤”할 수 있게 해둔 경우
    - ex) int의 크기(4byte인지 2byte인지)는 플랫폼마다 다름 → 하지만 그 플랫폼 안에서는 일관됨
- Undefined Behavior(UB) : 아예 보장 없음 → 절대 의존하면 안 됨.

### 포인터 기본

```c
int i;
int *ptr = &i; // i의 주소 저장
*ptr = 200;    // i에 200 저장
printf("%d\n", i);  // 200 출력
```

- 반드시 유효한 주소를 넣어야 함 (&변수, malloc)
- 주소 출력은 %p + (void*)

---

## 산술 연산자

- +   -   *   /   %
- 정수/정수 → 무조건 정수
- 정수/실수, 실수/실수 → 실수
- %는 정수 전용

```c
printf("%d\n", 3/2);       // 1
printf("%f\n", 3.0/2.0);   // 1.500000
printf("%f\n", (float)3/2);   // 1.500000
printf("%f\n", (float)(3/2)); // 1.000000
```

---

## 비교 연산자

- <   >   <=   >=   ==   !=
- 결과: 참(1) / 거짓(0)

```c
printf("%d\n", 3>8);     // 0
printf("%d\n", (3>8)+2); // 2
```

---

## 증가/감소 연산자

- ++a (전위): 먼저 증가 후 사용
- a++ (후위): 사용 후 증가

```c
int i=12,t,k;

t=i++;      // t=12, i=13
i=12;
k=100+ ++i; // i=13, k=113
```

> 한 식에서 같은 변수를 두 번 이상 증감시키면 UB
> 

---

## 논리 연산자

- && (AND): 둘 다 참일 때 참, **단락 평가**
- || (OR): 하나라도 참이면 참, **단락평가**
- ! (NOT): 참 ↔ 거짓 반전

```c
int i=12;
if(3>4 && (i++>100))
    printf("%d\n", i);
else
    printf("%d\n", i);   // i=12 (뒤는 실행 안 됨)
```

---

## 비트 연산자

- & (AND)
- | (OR)
- ^ (XOR)
- ~ (NOT)
- << (왼쪽 시프트 : x2)
- >> (오른쪽 시프트 /2, unsigned는 0채움

```c
unsigned char a=0b00001010; // 10
unsigned char b=0b00010010; // 18

printf("%d\n", a&b); // 2
printf("%d\n", a|b); // 26
printf("%d\n", a^b); // 24
printf("%d\n", a<<1); // 20
printf("%d\n", b>>1); // 9
```

---

## 실무에서 자주 쓰는 예시

```c
int i = 42;
double d = 3.14159;
char *s = "hello";

printf("[%7d]\n", i);          // [     42]
printf("[%-7d]\n", i);         // [42     ]
printf("[%07d]\n", i);         // [0000042]
printf("[%+7d]\n", i);         // [    +42]
printf("[% 7d]\n", i);         // [     42] (양수 앞 공백)

printf("[%10.3f]\n", d);       // [     3.142] (공백, 정수 포함 10자)
printf("[%+10.3f]\n", d);      // [    +3.142]
printf("[%.2e]\n", d);         // [3.14e+00]
printf("[%g]\n", d);           // [3.14159] (짧은 표기)

printf("[%.3s]\n", s);         // [hel] (문자열 최대 3글자)
printf("[%10s]\n", s);         // [     hello]
printf("[%-10s]\n", s);        // [hello     ]

size_t n = sizeof(long long);
printf("sizeof(long long) = %zu\n", n);   // size_t 정석
```

---

## 출력 버퍼 & 줄바꿈

- stdout은 보통 줄 단위 버퍼링: \n을 만나거나 버퍼가 차거나 fflush(stdout);를 호출할 때 실제로 화면에 보임.
- 즉, 줄 끝에 \n을 붙이면 출력이 즉시 보일 가능성이 큼.

---

## 반환값 & 에러

- printf는 성공 시 출력한 문자 수(널 제외)를, 실패 시 음수를 반환

```c
int cnt = printf(:"Hi\n"); //cnt == 3
```

---

## 초보가 자주하는 실수

1. 형식 문자열에 사용자 입력을 그대로 넣지 않기

```c
// 위험
printf(user_input);
// 안전
printf("%s", user_input);
```

1. 서식과 타입 불일치
- printf(”%d”, long_var); (X) → printf(”%ld”, long_var); (O)
- printf(”%d”, size_var); (X) → printf(”%zu”, size_var); (O)
- 주소는 %p만 사용
- scanf와 다름
- printf : %f는 double을 출력
- scanf : %f는 float*, %lf는 double* 임

---

## 연습 (답은 바로 아래 줄 주석)

```c
int a= = 7;
double x = 12.3456;
char *t = "C-language";

printf("[%07d]\n", a);          // [0000007]
printf("[%+8.2f]\n", x);        // [  +12.35]
printf("[%-10.5s]\n", t);       // [C-lang    ]
printf("addr=%p\n", (void*)&a); // addr=0x...
printf("%zu\n", sizeof t);      // 8 or 4 (포인터 크기)
printf("%zu\n", sizeof "abc");  // 4 (a b c \0)
```